Question 1
The purpose of ir-virtual? is to simulate how assembly works but in racket form. Some of the pros of using ir-virtual? would be that it looks like an assembly and feels familiar. 
Another pro to using ir-virtual? is that it lays out all the steps of the assembly code. ir-virtual? is also an easier version to understand than x86. 
One of the cons of ir-virtual would be that it is too simplistic. It can also sometimes oversimplify processes. 


Question 2
We created three examples .ifa programs each running different tests using +, -, and if statements. 
Each test ran smoothly with each test case without errors or bugs. For example on example2 when running the input 37, the input gets desugared down to ifarith-tiny. 
After going through irarith-tiny it gets sent to and where it turns into a simple argument from there getting sent to ir-virtual which turns it into an assembly.
After turning into an assembly it gets sent down to x86 which is the stack allocation, where it spits out the nasm file which is the assembled file. 
The example files were placed into the test-program file in the GitHub repo. 

Example's ran:

1)
input: (* (+ 1 2) (+ 3 4))
output: 21

2)
input:37
output:37
3)
input: '(if 1 (print (+ 2 2 )) (print (+ 1 2)))
output:#t 
-
Question 3
If the input is 37 that means 37 is in the surface level stage which gets put into the second 
stage. 
The second stage desugars it into 37 and from there goes into an administrative normal form which turns 
the input into a let (example: '(let ((x1254 37)) x1254). The next stage is ir-virtual which is the 
virtual assembly, which converts it into a simplified version of x86 with virtual registers (example: '(((label lab1255)
(mov-lit x1254 37)) (return x1254))). The second to last stage produces the actual x86 assembly with stack 
allocation and real registers after that the assembly file goes into a nasm. For example going from irarith 
to ifarith-tiny was very redundant because it produced the same input as the source. 

Question 4
Looking throughout the project we encountered many of the idioms we learned in class. Foldl was one of the idioms 
seen mainly in stage 5 of compiler.rkt. Lambda calculus is used to help us create a basis for how ifarith and ifarith-tiny
are supposed to function. Inside ifarith->ifarith-tiny match cases are used to contain all the cases needed when
going from ifarith to ifarith-tiny. Finally, another component of the function is the use of let and let* which 
we used in projects 3 and 4 to create binding cases for ifarith->ifarith-tiny.

Question 5
**April 26 at 2:31 pm initial bug for let* which was already done for us
**Changed the Let* and added quasi quoting which seemed to have fixed the issue
**A New Error appeared with an unbounded x we are looking into the cause of this issue
** The compiler.rkt doesn't support greater than when running .ifa. It gave the error "match: no matching clause for
('> 3 0)


High Level Reflection:
